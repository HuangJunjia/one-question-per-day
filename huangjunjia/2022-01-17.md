# Answer

### Last-Modified

当服务器返回资源给客户端时，会在响应首部中增加 `Last-Modified` 字段，值为 GMT 时间

客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回 `304` 状态码，**内容为空**，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回 `200` 状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个 `304` 响应比一个静态资源通常小得多，这样就节省了网络带宽。

#### 相关首部字段

1. `If-Modified-Since: Last-Modified-value`

    ```other
    If-Modified-Since: Thu, 31 Mar 2016 07:07:52 GMT
    ```

	该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送 `304`  和响应报头即可。

	当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。

2. `If-Unmodified-Since: Last-Modified-value`

	该值告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回 `412` (Precondition Failed) 状态码给客户端。

#### 缺陷

1. 感知时间间隔为 1s，如果**修改时间小于 1s** 则有可能文件编辑时间不会发生变化
2. 文件**内容未修改**也会造成文件最后编辑时间变化
3. 部分服务器无法获知精确的编辑时间

### ETag

优先级高于 Last-Modified

服务器会通过某种算法，给资源计算得出一个唯一标志符（比如 md5 标志），在把资源响应给客户端的时候，会在实体首部加上 `ETag: 唯一标识符` 一起返回给客户端

客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的 ETag 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改

如果服务器发现 ETag 匹配不上，那么直接以常规 GET `200` 回包形式将新的资源（当然也包括了新的 ETag ）发给客户端；如果 ETag 是一致的，则直接返回 `304` 知会客户端直接使用本地缓存即可。

#### 相关首部字段

1. `If-None-Match: ETag-value`

	告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送 `304` 和响应报头即可。 当前各浏览器均是使用的该请求首部来向服务器传递保存的 ETag 值。

2. `If-Match: ETag-value`

	告诉服务器如果没有匹配到 ETag，或者收到了 `*` 值而当前并没有该资源实体，则应当返回 `412` (Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段。

	**注意：如果资源是走分布式服务器（比如 CDN ）存储的情况，需要这些服务器上计算 ETag 唯一值的算法保持一致，才不会导致明明同一个文件，在服务器 A 和服务器 B 上生成的 ETag 却不一样。**

### 对比

![image](https://res.craft.do/user/full/701a5602-bdcf-b4e2-56a6-1eef78de0c40/doc/9CEBDE96-4AEB-4A19-9AB7-EBA048712A93/9458D783-96F0-4346-8CE3-4B26118AAA3F_2)
