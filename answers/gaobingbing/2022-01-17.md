### HTTP/1.1 中 ETag 和 Last-Modify 有什么区别，为什么有了 Last-Modify 还需要 ETag？

### 前提：

1. #### 从前端的角度理解缓存

   我们先来了解一下发送请求经历的过程

   **前端发送请求** => **服务器接收请求并且处理请求**  => **服务器响应数据**

   若是用户一直重复请求同一个资源，那么服务器会重复读取资源并且处理请求计算，这样会对服务器造成极大的浪费，并且也会造成不必要的一些事件消耗和等待，那么这个时候我们就可以利用缓存去解决这一问题。

2. #### 缓存读取并且发送请求的过程

   1. **前端发送请求** => **缓存中是否存在** => **存在直接返回资源**

   2. **前端发送请求** => **缓存中是否存在** => **不存在请求服务器资源** => **服务器接收请求并处理请求** => **返回资源**

      这样就能大大的减轻服务器的压力，从而提升效率

3. #### 缓存方法可以分为**强制缓存**和**协商缓存** （优先级：强制缓存 > 协商缓存）

   1. 强制缓存：给cache设置过期时间，超过时间就需要重新请求
   2. 协商缓存：根据一系列条件来约束和判断是否使用缓存。

### 解答

相同点：

  		1. ETag 和 Last-Modify 都是属于协商缓存

不同点:

1. Last-Modify 
   1. Last-Modify 通知的是上次修改资源的请求时间
   2. Last-Modify 与 IF-Modify-Since 对应的，浏览器将上次修改资源的值存储在IF-Modify-Since中，在下一次请求资源的时候，与服务器返回的Last-Modify进行比较，如果相等，则表示未修改，返回304，否则按照正常的请求处理。
2. ETag
   1. ETag是对资源的特殊标识
   2. ETag 与 IF-None-Match对应，第一次请求成功之后，将返回的ETag存入 IF-None-Match中，同样在下一次请求的时候，判断请求内容计算得到的ETag和 IF-None-Match 是否一直，若是相等，就表示没有更新，返回304， 否则按照正常请求处理。

###### 为什么有了 Last-Modify 还需要 ETag？

​	很多时候不能用时间来确定内容是否更新，那么此时Last-Modify 就不能满足我们的需求，就需要ETag，ETag是内容计算的一个标识，计算方式是可以自己定义的。

​	









