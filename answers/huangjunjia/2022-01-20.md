# Vue2 实现数组响应式的原理

## 原理

通过编写拦截方法覆盖 `Array.prototype` 的原生方法，每次执行方法的时候都会执行自定义的拦截方法，实现 Array 变化的追踪

## 缺陷

由于对 Array 的变化侦测是通过拦截原型的方法实现的，对数组的部分操作无法进行拦截

如：

```vue
this.list[0] = 2;
```

## 总结

1. Array 与 Object 追踪变化的方式不同，Array 是通过拦截器覆盖数组原型的方法来实现追踪变化
2. 为了不污染全局 `Array.prototype`，通过对需要侦测变化的数组的 `__proto__` 覆盖数组的原型方法来实现对数组变化的侦测，但是不是所有浏览器都支持该属性，当在不支持 `__proto__` 属性的浏览器中，Vue.js 通过将拦截器直接设置在数组的原型链上拦截 `Array.prototype` 的原生方法
3. Array 收集依赖的方式和 Object 一样，都是在 `getter` 中收集，但是由于使用依赖的位置不同，数组在拦截器中向依赖（Watcher）发送消息，所以依赖不能像 Object 那样保存在 `defineReactive` 中，而是把依赖保存在 Observer 实例上
4. 在`Observer`中，对每个侦测了变化的数据都标上印记 `__ob__`，并把`this`（`Observer`实例）保存在 `__ob__` 上。这主要有两个作用，一方面是为了标记数据是否被侦测了变化（保证同一个数据只被侦测一次），另一方面可以很方便地通过数据取到 `__ob__`，从而拿到 `Observer` 实例上保存的依赖。当拦截到数组发生变化时，向依赖发送通知
5. 除了侦测数组自身的变化外，数组中元素发生的变化也要侦测。在 `Observer` 中判断如果当前被侦测的数据是数组，则调用 `observeArray` 方法将数组中的每一个元素都转换成响应式的并侦测变化
6. 除了侦测已有数据外，当用户使用 `push` 等方法向数组中新增数据时，新增的数据也要进行变化侦测。我们使用当前操作数组的方法来进行判断，如果是 `push`、`unshift` 和 `splice` 方法，则从参数中将新增数据提取出来，然后使用 `observeArray` 对新增数据进行变化侦测
7. 由于在ES6之前，JavaScript并没有提供元编程的能力，所以对于数组类型的数据，一些语法无法追踪到变化，只能拦截原型上的方法，而无法拦截数组特有的语法，例如使用 `length` 清空数组的操作就无法拦截
