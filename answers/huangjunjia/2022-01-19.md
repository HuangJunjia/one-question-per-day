## 过程

1. DNS解析，将域名解析成 IP 地址
2. TCP连接，TCP三报文握手
3. 发送 HTTP 请求
4. 服务器永久重定向
5. 服务器处理请求并返回 HTTP 报文
6. 浏览器解析渲染页面
7. 断开连接，TCP四次挥手


----

1. ## 输入URL


### URL


定义：统一资源定位符（Uniform Resource Locator），俗称：网页地址或者网址

URL 大多数为 9部分 构成的，语法如下：

```other
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
```


### 参数


- #### scheme

	- 中文名：方案
	- 描述：访问服务器以获取资源时要使用哪种协议

- #### user

	- 中文名：用户
	- 描述：某些方案访问资源时需要的用户名

- #### password

	- 中文名：密码
	- 描述：户名后面可能要包含的密码，中间由冒号(:)分隔

- #### host

	- 中文名：主机
	- 描述：一般为ip地址，资源宿主服务器的主机名或点分 IP 地址

- #### port

	- 中文名：端口
	- 描述：资源宿主服务器正在监听的端口号

- #### path

	- 中文名：路径
	- 描述：服务器上资源的本地名

- #### params

	- 中文名：参数
	- 描述：某些方案会用这个组件来指定输入参数

- #### query

	- 中文名：查询
	- 描述：某些方案会用这个组件传递参数以激活应用程序

- #### frag

	- 中文名：片段
	- 描述：一小片或一部分资源的名字

### 过程

1. 用户在地址栏中输入查询关键字
2. 判断用户输入的是 **搜索关键字** 或者 **请求的URL**
	1. 如果是 搜索关键字，地址栏会使用浏览器默认的搜索引擎，合成新的带搜索关键字的 URL
	2. 如果输入的内容符合 URL 规则，浏览器则会根据规则补全成完整的 URL，如：github.com 补全为 http://github.com
3. 按下回车键之后，浏览器会执行以下流程：
	1. 执行 beforeunload 事件，该事件允许页面在退出之前执行一些操作，如数据清理操作，并询问用户是否离开当前页面，如表单未提交提示，如果用户通过 beforeunload 事件来取消导航，则浏览器不会执行后续操作
	2. 如果当前页面没有监听 beforeunload 事件，则浏览器会进入加载状态，但是页面并未开始替换和渲染
	3. 如果是 chrome 浏览器，在缓存中如果存在 URL 指向的页面，则会将缓存中的页面取出并渲染
4. 执行后续流程


----

2. ## DNS解析，将域名解析成 IP 地址


DNS 解析的过程就是为了寻找哪台机器上有需要的资源的过程

### DNS定义


DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）

### 资源查找顺序

> 浏览器缓存 —> 操作系统缓存 —> hosts 文件 —> 路由器缓存 —> ISP DNS缓存 —>  顶级DNS服务器/根DNS服务器


### 查找过程

1. 在**浏览器缓存**中查找
2. 在**操作系统运行内存**中查找
3. 在 **host 文件**中查找，查看是否存在相关规则，如果有直接返回该规则对应的 IP 地址
4. 在**路由器缓存**中查找，路由器会记录访问的 DNS 及 域名
5. 在 **ISP DNS 缓存**中查找，互联网服务提供商（如中国电信）也会提供 DNS 服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向 ISP 进行查询，ISP 会在当前服务器的缓存内查找是否有记录，如果有，则返回这个 IP，若没有，则会开始向**根域名服务器**请求查询
6. **根域名**收到请求后，会判别这个域名（.com）是授权给哪台服务器管理,并返回这个顶级 DNS 服务器的 IP。请求者收到这台顶级 DNS 的服务器 IP 后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的 DNS 服务器 IP（nicefilm.com），本机继续查找，直到服务器找到(www.nicefilm.com)的主机
7. 本地 DNS 服务器向域名的解析服务器发出请求，这时就能收到一个域名和 IP 地址对应关系，本地 DNS 服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问

![image](https://res.craft.do/user/full/701a5602-bdcf-b4e2-56a6-1eef78de0c40/doc/9CEBDE96-4AEB-4A19-9AB7-EBA048712A93/B37D0E60-4C83-4956-BB47-7F8818A908D8_2)

### DNS 查询方式

1. 递归查询

	当局部 DNS 服务器自己不能回答客户机的 DNS 查询时，它就需要向其他 DNS 服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他 DNS 服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部 DNS 服务器，再由局部 DNS 服务器返回给客户端

![image](https://res.craft.do/user/full/701a5602-bdcf-b4e2-56a6-1eef78de0c40/doc/9CEBDE96-4AEB-4A19-9AB7-EBA048712A93/3FDD9F57-FE26-42AF-8BFC-B24547F695AD_2)


2. 迭代查询

	当局部 DNS 服务器自己不能回答客户机的 DNS 查询时，也可以通过迭代查询的方式进行解析，如图所示。局部 DNS 服务器不是自己向其他 DNS 服务器进行查询，而是把能解析该域名的其他 DNS 服务器的IP地址返回给客户端 DNS 程序，客户端 DNS 程序再继续向这些 DNS服 务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com 的服务器 IP 地址在 192.168.4.5 这里，你自己去查吧，本人比较忙，只能帮你到这里了

![image](https://res.craft.do/user/full/701a5602-bdcf-b4e2-56a6-1eef78de0c40/doc/9CEBDE96-4AEB-4A19-9AB7-EBA048712A93/285E8C8A-16DF-4761-A3AB-BAA13B29C428_2)

### DNS域名称空间的组织方式


根 DNS 服务器，域 DNS 服务器，这些都是 DNS 域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例

![image](https://res.craft.do/user/full/701a5602-bdcf-b4e2-56a6-1eef78de0c40/doc/9CEBDE96-4AEB-4A19-9AB7-EBA048712A93/0613EFEC-F42A-4171-8525-8489A3FC534D_2)

### 优化方式

1. DNS 缓存

	DNS 存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存、系统缓存、路由器缓存、IPS 服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存


2. DNS 负载均衡

	当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用 DNS 负载均衡技术，它的原理是**在 DNS 服务器中为同一个主机名配置多个 IP 地址**，在应答 DNS 查询时，DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等
----

3. ## TCP 连接


拿到域名对应的 IP 地址之后，浏览器会以一个随机端口（1024 < 端口 < 65535）向服务器的 WEB 程序（常用的有 httpd，nginx 等）80 端口发起 TCP 的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的 TCP/IP 协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过 Netfilter 防火墙（属于内核的模块）的过滤，最终到达 WEB 程序，最终建立了 TCP/IP 的连接

![image](https://res.craft.do/user/full/701a5602-bdcf-b4e2-56a6-1eef78de0c40/doc/9CEBDE96-4AEB-4A19-9AB7-EBA048712A93/177B3762-A4FC-4018-B09C-74572BB2A1FE_2)

### 三报文握手

1. 第一次握手：建立连接时，客户端发送 syn 包（ syn=j ）到服务器，并进入 **SYN-SENT** 状态，等待服务器确认；SYN：同步序列编号（ Synchronize Sequence Numbers ）。
2. 第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ ack=j+1 ），同时自己也发送一个 SYN 包（syn=k），即 SYN + ACK 包，此时服务器进入 **SYN-RECV** 状态；
3. 第三次握手：客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK（ack=k+1），此包发送完毕，客户端和服务器进入 **ESTABLISHED**（ TCP 连接成功）状态，完成三次握手。


----

4. ## 发送 HTTP 请求


建立了TCP连接之后，发起一个http请求

### HTTP 报文组成


 HTTP 报文包含三个部分，对报文 进行描述的**起始行(start line)**、包含属性的**首部(header)块**，以及可选的、包含 数据的**主体(body)**部分

报文可分为两类：


1. 请求报文

    ```other
    <method> <request-URL> <version>
    <headers>
    
    <entity-body>
    ```

2. 响应报文

    ```other
    <version> <status> <reason-phrase>
    <headers>
    
    <entity-body>
    ```


各部分释义


- 方法(method)

	客户端希望服务器对资源执行的动作。是一个单独的词，比如 GET、HEAD 或 POST。本章稍后将详细介绍方法。


- 请求 URL(request-URL)

	命名了所请求资源，或者 URL 路径组件的完整 URL。如果直接与服务器进行对话，只要 URL 的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是 URL 的主机 / 端口。


- 版本(version)

	报文所使用的 HTTP 版本，其格式看起来是这样的:

    ```other
    HTTP/<major>.<minor>
    ```


	其中主要版本号(major)和次要版本号(minor)都是整数。


- 状态码(status-code) 

	这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描 述状态的一般类别(“成功”、“出错”等)


- 原因短语(reason-phrase)

	数字状态码的可读版本，包含行终止序列之前的所有文本。本章稍后提供了 HTTP 规范定义的所有状态码的原因短语示例。原因短语只对人类有意义，因 此，比如说，尽管响应行 HTTP/1.0 200 NOT OK 和 HTTP/1.0 200 OK 中原因短 语的含义不同，但同样都会被当作成功指示处理。


- 首部(header)

	可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号(:)，然 后是一个可选的空格，接着是一个值，最后是一个 CRLF。首部是由一个空行(CRLF)结束的，表示了首部列表的结束和实体主体部分的开始。有些 HTTP 版 本，比如 HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部。


- 实体的主体部分(entity-body)

	实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实 体的主体部分，有时，报文只是以一个 CRLF 结束。

![image](https://res.craft.do/user/full/701a5602-bdcf-b4e2-56a6-1eef78de0c40/doc/9CEBDE96-4AEB-4A19-9AB7-EBA048712A93/894B3BE2-D539-4D31-BCEC-5664A7BCBFA8_2)
----

5. ## 服务器永久重定向


客户端接收到服务端返回的响应报文之后，会解析报文的起始行，如果响应状态码是「200」则进行下一步；如果是「301」或者「302」，那么说明需要重定向到响应首部「Location」字段指向的 URL，这时浏览器网络进程会读取响应首部「Location」字段的值，并重新发起新的 HTTP 或者 HTTPS 请求
----

6. ## 服务器处理请求


服务器接收浏览器网络进程发送的 HTTP 请求，处理之后向客户端返回响应报文

后端从在固定的端口接收到 TCP 报文开始，它会对 TCP 连接进行处理，对 HTTP 协议进行解析，并按照报文格式进一步封装成 HTTP Request 对象，供上层使用

### 负载均衡


将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理，并通过 Nginx 服务器转发至具体的机器上

![image](https://res.craft.do/user/full/701a5602-bdcf-b4e2-56a6-1eef78de0c40/doc/9CEBDE96-4AEB-4A19-9AB7-EBA048712A93/48A7E8A1-0AC3-4482-80A2-65CE4535FAA7_2)

### 反向代理


客户端本来可以直接通过 HTTP 协议访问某网站应用服务器，网站管理员可以在中间加上一个 Nginx，客户端请求 Nginx，Nginx 请求应用服务器，然后将结果返回给客户端，此时 Nginx 就是反向代理服务器

![image](https://res.craft.do/user/full/701a5602-bdcf-b4e2-56a6-1eef78de0c40/doc/9CEBDE96-4AEB-4A19-9AB7-EBA048712A93/44D02D1D-E83C-47D7-B3C9-DB7902F65BEC_2)
----

7. ## 服务器返回 HTTP 响应


服务端会把它的处理结果返回，也就是返回一个 HTTP 响应，[响应报文格式参考](craftdocs://open?blockId=A2300342-E31F-4964-9008-0B707C648D86&spaceId=701a5602-bdcf-b4e2-56a6-1eef78de0c40)，同时在响应报文首部的「Content-Type」字段告诉浏览器返回的主体的数据格式

如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了
----

8. ## 浏览器准备渲染进程


默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中

### 同一站点（same-site）


将“**同一站点**”定义为**根域名**（例如，nodejs.org）加上**协议**（例如，https:// 或者 http:// ），还包含了该根域名下的**所有子域名和不同的端口**

Chrome 的默认策略是，每个标签对应一个渲染进程。但**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程**。官方把这个默认策略叫 process-per-site-instance

### 不同站点


当新页面和当前页面不属于同一站点，新页面会使用一个新的渲染进程

### 总结


打开一个新页面采用的渲染进程策略就是：


1. 通常情况下，打开新的页面都会使用单独的渲染进程；
2. 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段
----

9. ## 浏览器解析并渲染 HTML


当浏览器渲染进程准备完毕，且服务器 HTTP 响应数据已经获取结束的情况下，浏览器网络进程会将 HTML 数据提交给渲染进程，具体流程如下：


1. 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
2. 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
3. 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
4. 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面

其中，当浏览器进程确认提交之后，更新内容如下图所示

![image](https://res.craft.do/user/full/701a5602-bdcf-b4e2-56a6-1eef78de0c40/doc/9CEBDE96-4AEB-4A19-9AB7-EBA048712A93/0D126AFD-9D6F-4907-BE30-CF22A9A7B4E6_2)

这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段，一旦文档被提交，渲染进程便开始页面解析和子资源加载[https://segmentfault.com/a/1190000010298038](https://segmentfault.com/a/1190000010298038)

以下内容参考：

[https://segmentfault.com/a/1190000010298038](https://segmentfault.com/a/1190000010298038)

[https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)

基本过程如下：


1. HTML解析出DOM Tree
2. CSS解析出Style Rules
3. 将二者关联生成Render Tree
4. Layout 根据Render Tree计算每个节点的信息
5. Painting 根据计算好的信息绘制整个页面

### 构建 DOM


当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树

将文本的HTML文档，提炼出关键信息，嵌套层级的树形结构，便于计算拓展。这就是HTML Parser的作用

![image](https://res.craft.do/user/full/701a5602-bdcf-b4e2-56a6-1eef78de0c40/doc/9CEBDE96-4AEB-4A19-9AB7-EBA048712A93/59431E8C-A9B8-4DB2-9D50-8A0288C0E863_2)

注意：DOM 树的生成过程中可能会被CSS和JS的加载执行阻塞

### 构建 CSSOM 规则树


浏览器解析 CSS 文件并生成 CSS 规则树，每个 CSS 文件都被分析成一个 StyleSheet 对象，每个对象都包含 CSS 规则。CSS 规则对象包含对应于 CSS 语法的选择器和声明对象以及其他对象。

### 渲染阻塞


当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建 DOM。每次去执行 JavaScript 脚本都会严重地阻塞 DOM 树的构建，如果 JavaScript 脚本还操作了 CSSOM，而正好这个 CSSOM 还没有下载和构建，浏览器甚至会延迟脚本执行和渲染 DOM，直至完成其 CSSOM 的下载和构建。

所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：


1. CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
2. JS置后：我们通常把 JS 代码放到页面底部，且 JavaScript 应尽量少影响 DOM 的构建。

当解析 html 的时候，会把新来的元素插入 DOM 树里面，同时去查找 CSS，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。

### 构建渲染树


通过 DOM 树和 CSS 规则树我们便可以构建渲染树。浏览器会先从 DOM 树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的 CSS 样式规则并应用。

渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与 DOM 树的最大区别所在。渲染树是用于显示，不可见的元素不会在这棵树中出现；display 等于 none 的也不会被显示在这棵树里头，但是 visibility 等于 hidden 的元素是会显示在这棵树里头的。

### 渲染树布局


布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。

### 渲染树绘制


在绘制阶段，遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。

#### reflow与repaint：


根据渲染树布局，计算 CSS 样式，即每个节点在页面中的大小和位置等几何信息。HTML 默认是流式布局的，CSS 和 js 会打破这种布局，改变 DOM 的外观样式以及大小和位置。这时就要提到两个重要概念：replaint 和 reflow。


- repaint

	屏幕的一部分重画，不影响整体布局，比如某个 CSS 的背景色变了，但元素的几何尺寸和位置不变。


- reflow

	意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是 Reflow，或是 Layout。

所以我们应该尽量减少 reflow 和 repaint，我想这也是为什么现在很少有用 table 布局的原因之一。

display: none 会触发 reflow，visibility: hidden 属性并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框，所以 visibility: hidden 只会触发 repaint，因为没有发生位置变化。

有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。

有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。
----

10. ## 断开 TCP 连接

