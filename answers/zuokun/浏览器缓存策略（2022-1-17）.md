# 起

每日一题：HTTP/1.1 中 ETag 和 Last-Modify 有什么区别，为什么有了 Last-Modify 还需要 ETag？

题干提到了Etag与Last-Modify，**提问的目的是考察对于浏览器缓存的理解与常见的使用场景**

# 承

## 浏览器缓存

浏览器作为web开发的承载体，如何提高性能表现，是作为一名前端开发所必须要了解的。（虽然在此之前，只是知道有这么个东西，这是第一次总结记录）

提升性能表现，缓存机制就是最经典的解决方案之一，浏览器缓存分为两种，分别是**强缓存**与**协商缓存**

### 强缓存

浏览器中的强缓存分为两种：

 - **expires**
 
 - **cache-control**
 
**expires**：是响应头中的一个字段，当浏览器向服务器发送第一次请求时（这里的第一次指的是某一个请求的第一次请求），浏览器在响应头中给出的一个值，这个值是一个GMT时间格式字符串，如果下一次需要发出的请求在该时间之前，则命中缓存，浏览器就不会再次发送请求，而是改为从本地缓存直接读取数据

**cache-control**：这东西的值可以列一个表格，并且多个值是可以同时存在的，我们可以记住几个重要的值

 - -no-store: 优先级最高的一个值，意思是直接禁止浏览器使用缓存，多个有矛盾的值同时存在的话，该值优先级最高
 - max-age: 告诉服务器或者浏览器，资源在多少时间内（单位为秒），是新鲜的，无需再次请求
 
cache-control的值有些可以放在请求头，有些可以放在响应头，有些都可以存在，他们代表的意义都相近


# 转

### 协商缓存

题干中提到的两个关键字ETag和Last-Modify，都是协商缓存。那么这两者分别有什么区别呢

#### Last-Modify

当浏览器第一次请求一个资源时，响应头中last-modifed字段会携带一个GMT时间格式的字符串，这代表着该资源在服务器上最后一次的修改时间是多少，那么在下一次请求时，浏览器请求头就会携带一个is-modified-since，这个值就是响应头last-modified所携带的值，服务端拿到该值之后，如果服务端资源没有发生变化，返回304，浏览器就会加载本地缓存，反之则返回新的资源

#### ETag

其实和Last-Modify方法不同之处，就在于对比的是时间，还是一个key值。

当浏览器第一次请求一个资源时，服务端会返回200，并且响应头中会携带一个etag字段，该字段保存了一个字符串值，当下一次同样的请求发起后，请求头中就会携带一个is-none-match的字段，其值为etag返回的值，服务端就会根据该值来判断资源是否更改，当配置nginx中etag选项默认开启时，每次服务器更新资源，都会生产新的etag值。

# 合

那么整体的去看这个问题：

**Etag和Last-Modify的区别在于我们比较的基准是一个时间，还是一个会根据资源更新而变动的key值**

**由于对比的基准不同，所以两者的适用场景也会有区别**

(1) 当文件更新的速度非常快的时候，快到低于秒的级别，Last-Modify显然是无法确保当前是最新资源的，因为UNIX记录MTIME（磁盘最后一次修改时间）只能到秒

(2) 某些服务器不能精确地得到文件修改时间，这种情况和上述情况类似

(3) 一些文件也许会周期性的进行更改，但是更改的只是修改时间，本身资源并没有实际的改变，这样的情况下也是没有必要去重新获取资源的，所以这种情况下，last-modify也是无法准确判断的

